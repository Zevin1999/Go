package leetcode

/*
1. 二叉树的镜像
+ 使用递归解法，递归结束条件root==nil, 递归：根的左右节点递归交换left := mirrorTree(root.Left) right := mirrorTree(root.Right)，最后交换根结点的左右节点root.Left, root.Right = right, left，返回root
+ 时间复杂度 O(N) 空间复杂度 由递归栈的深度决定，平均情况树高度与节点个数成对数关系O(logN)最坏链状结构O(N)
2. 重建二叉树
+ 使用递归解法，递归结束条件len(preorder)==0, 递归：在preorder和inorder中找到根结点，继而判断根结点的左右节点，递归左右节点，返回root
+ 时间复杂度 O(N) 空间复杂度 O(N)
3. 树的子结构
+ 使用递归解法，辅助递归函数判断A树B树||递归A树左子树B树||递归A树右子树B树， 辅助递归函数判断A树左子树B树左子树&&A树右子树B树右子树的值，结束条件B==nil
+ 时间复杂度  O(MN) 空间复杂度 O(M)
4. 从上到下打印二叉树I
+ 使用广度优先遍历，队列存储根结点，出队时不断遍历其左右节点
+ 时间复杂度 O(N) 空间复杂度 O(N)
5. 从上到下打印二叉树II
+ 使用广度优先搜索遍历， pre记录root节点，cur记录左右子节点，遍历pre的同时，向res数组增加值，向cur增加pre的左右子节点，一次遍历完成，用cur替换pre，直至树遍历完成。
+ 时间复杂度 O(N) 空间复杂度 O(N)
6. 从上到下打印二叉树III
+ 只需将奇数层的数组元素进行翻转，核心思想和II一致，除此之外只需判断数组元素是否为奇数位（level%2==1），若是则进行翻转
+ 时间复杂度 O(N) 空间复杂度 O(N)
7. 二叉树的深度
+ 使用深度优先遍历以及递归，递归结束条件 root == nil ，递归 height = max（左子树，右子树）+ 1
+ 时间复杂度 O(N) 空间复杂度 O(h) h为递归栈空间，取决于二叉树的高度

+ 使用广度优先遍历，遍历每一层，最终得到的总层数就是二叉树深度
+ 时间复杂度 O(N) 空间复杂度 O(N)
8. 对称的二叉树
+ 使用递归解法，递归结束结束时左右子树节点为空，即都为nil，递归时判断节点值是否相同，并继续递归判断节点的左子树左节点和右子树右节点以及左子树右节点和右子树左节点
+ 时间复杂度 O(N) 空间复杂度 O(N)

+ 迭代，数组按照左子树左节点、右子树右节点、左子树右节点、右子树左节点的顺序增添元素并判断
+ 时间复杂度 O(N) 空间复杂度 O(N)
9. 二叉搜索树的后序遍历序列
+ 递归分治 p==j判断树是否正确，继续递归判断recur(i,m−1)左子树以及recur(m,j−1)右子树
+ 时间复杂度 O(N2)[树状退化为链表] 空间复杂度 O(N)
10. 二叉搜索树的第k大节点
+ 中序遍历是递增顺序，中序遍历倒序是递减顺序，第k大是中序遍历倒序序列的第k-1个元素
+ 时间复杂度 O(N) 空间复杂度 O(N)
*/
