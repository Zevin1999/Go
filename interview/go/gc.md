1. Golang垃圾回收是怎么进行的? 
   三色标记算法 【对标记清除阶段的改进】
   原理： 起初所有对象都是白色。
         从根出发扫描所有可达对象，标记为灰色，放入待处理队列。
         从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。
         不断重复，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。 
   1. 首先从root开始遍历，root包括全局指针和goroutine栈上的指针。 
   2. mark有两个过程
      1. 从 root 开始遍历，标记为灰色。遍历灰色队列。 
      2. re-scan 全局指针和栈。因为 mark 和用户程序是并行的，所以在过程 1 的时候可能会有新的对象分配，这个时候就需要通过写屏障（write barrier）记录下来。re-scan 再完成检查一下。 
   3. Stop The World 有两个过程。
      1. 第一个是 GC 将要开始的时候，这个时候主要是一些准备工作，比如 enable write barrier。 
      2. 第二个过程就是上面提到的 re-scan 过程。如果这个时候没有 stw，那么 mark 将无休止( 1.8 版本后此步骤取消)。

2. Go1.3采用标记清除法， Go1.5采用三色标记法，Go1.8采用三色标记法+混合写屏障。
   1. 标记清除法分为两个阶段：标记和清除 
      1. 标记阶段：从根对象出发寻找并标记所有存活的对象。 
      2. 清除阶段：遍历堆中的对象，回收未标记的对象，并加入空闲链表。 
      缺点是需要暂停程序STW。
   2. 三色标记法(将对象标记为白色，灰色或黑色)
      白色：不确定对象（默认色）；黑色：存活对象。灰色：存活对象，子对象待处理。 
      1. 标记开始时，先将所有对象加入白色集合（需要STW）。 
      2. 首先将根对象标记为灰色，然后将一个对象从灰色集合取出，遍历其子对象，放入灰色集合。同时将取出的对象放入黑色集合，直到灰色集合为空。
         最后的白色集合对象就是需要清理的对象。 
      这种方法有一个缺陷，如果对象的引用被用户修改了，那么之前的标记就无效了。因此Go采用了写屏障技术，当对象新增或者更新会将其着色为灰色。
   3. 三色标记法+混合写屏障
      完整的GC分为四个阶段
      1. 准备标记（需要STW），开启写屏障。 
      2. 开始标记 
      3. 标记结束（STW），关闭写屏障 
      4. 清理（并发） 
   5. 混合写屏障分为以下四步：
      1. GC开始时，将栈上的全部对象标记为黑色（不需要二次扫描，无需STW)
      2. GC期间，任何栈上创建的新对象均为黑色 
      3. 被删除引用的对象标记为灰色 
      4. 被添加引用的对象标记为灰色
      

3. gc有几个阶段？ 
   目前的go GC采用三色标记法和混合写屏障技术。
   Go GC有四个阶段:
   1. STW，开启混合写屏障，扫描栈对象； 
   2. 将所有对象加入白色集合，从根对象开始，将其放入灰色集合。每次从灰色集合取出一个对象标记为黑色，然后遍历其子对象，标记为灰色，放入灰色集合；如此循环直到灰色集合为空。剩余的白色对象就是需要清理的对象。 
   3. STW，关闭混合写屏障； 
   4. 在后台进行GC（并发）。
4. 如何知道一个对象是分配在栈上还是堆上？
   Go和C++不同，Go局部变量会进行逃逸分析。如果变量离开作用域后没有被引用，则优先分配到栈上，否则分配到堆上。