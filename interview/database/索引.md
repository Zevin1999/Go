1. 数据库索引使用B+树不使用平衡二叉树的原因
   InnoDB的索引使用的是B+树实现，B+树对比B树的好处：
   1. IO次数少，B+树的中间结点只存放索引，数据都存放在叶子节点中，因此中间结点可以存更多的数据，让索引树更加矮胖
   2. 范围查询效率更高：B树需要中序遍历整个树，B+树只需要遍历叶子结点中的链表
   3. 查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多
2. 那些情况下索引会失效
   1. 在where子句中进行null值判断(is null,is not null). eg: SELECT id FROM table WHERE num is null)
   2. where子句中使用!= 或者< >这样的不等符号 eg:SELECT id FROM table WHERE num != 0
   3. where子句中使用or来连接条件,如果俩个字段中有一个没有索引的话,引擎会放弃索引而产生全表扫描
   4. 使用表达式操作或者函数操作. eg:SELECT id FROM table WHERE num / 2 = 1
   5. like以通配符开头.eg: SELECT id FROM table WHERE name like "%abc"
   6. 类型转换(字符串不加引号)导致的索引失效. eg: SELECT id FROM table WHERE name = 186
   7. 联合索引不满足最左原则, eg: index(name,age,email); SELECT id FROM table WHERE age = 10 and email="12@qq.com"
   8. 如果MySQL估计全表扫描比索引快，则不使用索引（比如非常小的表）
3. 如何优化数据库?
   1. SQL语句的优化 
      [分析慢查询日志：记录了在MySQL中响应时间超过阀值long_query_time的SQL语句，通过日志去找出IO大的SQL以及发现未命中索引的SQL;
      使用Explain进行分析：通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及被扫描的行数等问题]
      1. 应尽量避免在 where 子句中使用!=、< >操作符或对字段进行null值判断，否则引擎将放弃使用索引而进行全表扫描；
      2. 只返回必要的列：最好不要使用 SELECT * 语句；
      3. 只返回必要的行：使用LIMIT语句来限制返回的数据；
      4. 将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联 
         1. 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用
         2. 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余的查询；
         3. 减少锁竞争
   2. 索引的优化
      [注意会引起索引失效的情况，以及在适合的地方建立索引]
   3. 数据库表结构的优化
      1. 设计表时遵循三大范式 
         第一范式(确保每列保持原子性)
         第二范式(确保表中的每列都和主键相关)
         第三范式(确保每列都和主键列直接相关,而不是间接相关)
      2. 选择合适的数据类型：尽可能不要存储NULL字段；使用简单的数据类型 int, varchar/text
      3. 表的水平切分（Sharding）：将同一个表中的记录拆分到多个结构相同的表中（策略：哈希取模；根据ID范围来分）。当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓解单个数据库的压力
      4. 表的垂直切分：将一张表按列切分成多个表。可以将不常用的字段单独放在同一个表中；把大字段独立放入一个表中；或者把经常使用的字段（关系密切的）放在一张表中。垂直切分之后业务更加清晰，系统之间整合或扩展容易，数据维护简单
   4. 系统配置的优化
      1. 操作系统：增加TCP支持的队列数
      2. MySQL配置文件优化：缓存池大小和个数设置
   5. 硬件的优化
      1. 磁盘性能：固态硬盘
      2. CPU：多核且高频
      3. 内存：增大内存 
      [4.5参考 http://www.icodebang.com/article/377424]